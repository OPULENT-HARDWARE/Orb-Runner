<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Orb Runner — BY OPULENT HARDWARE</title>
<link href="https://fonts.googleapis.com/css2?family=Saira:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg: #000000;
    --gridGlow: #00ff4c;   /* green default */
    --hud: #e8e8e8;
    --hudDim: #9aa0a6;
    --radius: 16px;
    --halo: rgba(255,255,255,0.12);
    --halo-strong: rgba(255,255,255,0.25);
    --brand: rgba(255,255,255,0.9);
  }
  html, body {
    height: 100%; width: 100%; margin: 0;
    background: var(--bg); color: var(--hud);
    font-family: "Saira", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overscroll-behavior: none; touch-action: none;
    -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;
  }
  * { -webkit-tap-highlight-color: transparent; }

  .stage {
    position: fixed; inset: 0;
    background:
      radial-gradient(1200px 800px at 50% 50%, rgba(0,255,76,0.07), transparent 60%),
      radial-gradient(900px 600px at 50% 50%, rgba(54,168,255,0.05), transparent 60%),
      radial-gradient(100% 100% at 50% 120%, rgba(0,0,0,0.6), rgba(0,0,0,1));
  }
  canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; pointer-events: auto; }

  /* HUD */
  .hud {
    position: absolute; left: 12px; right: 12px; top: 10px;
    display: grid; grid-template-columns: 1fr auto 1fr;
    align-items: center; gap: 10px; z-index: 100; text-shadow: 0 0 10px rgba(0,0,0,0.6);
    pointer-events: none;
  }
  .hud-left, .hud-center, .hud-right { display: flex; align-items: center; gap: 10px; }
  .hud-left  { justify-content: flex-start; }
  .hud-center{ justify-content: center;     pointer-events: auto; }
  .hud-right { justify-content: flex-end;   }
  .badge {
    padding: 6px 10px; border-radius: 999px; white-space: nowrap; font-weight: 700; letter-spacing: .4px;
    background: rgba(255,255,255,0.06);
    box-shadow: 0 0 24px rgba(0,0,0,0.5) inset, 0 0 24px rgba(0,0,0,0.4);
  }
  .ctl {
    padding: 8px 14px; border-radius: 999px; user-select: none; cursor: pointer; font-weight: 800; letter-spacing: .4px;
    background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12);
    box-shadow: 0 0 0 1px rgba(255,255,255,0.04) inset, 0 10px 25px rgba(0,0,0,0.55);
    backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); color: var(--hud);
    touch-action: manipulation;
  }
  .ctl:active { transform: scale(0.98); }
  .ctl.active { background: rgba(255,255,255,0.16); border-color: rgba(255,255,255,0.3); }
  .brand { white-space: nowrap; font-weight: 700; color: var(--brand); opacity: 0.95; }

  /* Swipe Pad */
  .swipe-wrap{
    position: absolute; bottom: 22px; left: 50%; transform: translateX(-50%);
    width: min(38vw, 220px); height: min(38vw, 220px);
    display: grid; place-items: center; z-index: 100; pointer-events: auto;
  }
  .swipe-pad{
    width: 100%; height: 100%; border-radius: 50%;
    background:
      radial-gradient(closest-side, rgba(255,255,255,0.03), transparent 60%),
      radial-gradient(closest-side, rgba(0,0,0,0.25), transparent 70%);
    border: 2px solid var(--halo);
    box-shadow: 0 0 18px var(--halo), inset 0 0 22px rgba(255,255,255,0.06);
    position: relative;
  }
  .swipe-pad::after{ content:""; position:absolute; inset:10%; border-radius:50%; border: 1px dashed rgba(255,255,255,0.12); }
  .streak{
    position: absolute; width: 6%; height: 40%; top: 10%; left: 47%; border-radius: 999px;
    background: radial-gradient(closest-side, rgba(255,255,255,0.85), rgba(255,255,255,0.1));
    box-shadow: 0 0 18px rgba(255,255,255,0.4); transform-origin: 50% 100%; opacity: 0; transition: opacity 120ms ease;
    pointer-events: none;
  }
  .pulse{ animation: halo 260ms ease; }
  @keyframes halo {
    0%   { box-shadow: 0 0 18px var(--halo), inset 0 0 22px rgba(255,255,255,0.06); border-color: var(--halo); }
    50%  { box-shadow: 0 0 26px var(--halo-strong), inset 0 0 28px rgba(255,255,255,0.14); border-color: var(--halo-strong); }
    100% { box-shadow: 0 0 18px var(--halo), inset 0 0 22px rgba(255,255,255,0.06); border-color: var(--halo); }
  }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>

    <!-- HUD -->
    <div class="hud" id="hud" aria-label="HUD">
      <div class="hud-left">
        <div class="badge" id="score">SCORE 0</div>
        <div class="badge" id="length">LEN 1</div>
      </div>

      <!-- SPEED CONTROLS (Medium = slowest, default) -->
      <div class="hud-center" aria-label="Speed Controls">
        <div class="ctl active" id="mediumBtn" role="button" tabindex="0" aria-pressed="true">MEDIUM</div>
        <div class="ctl" id="fastBtn"   role="button" tabindex="0" aria-pressed="false">FAST</div>
        <div class="ctl" id="hyperBtn"  role="button" tabindex="0" aria-pressed="false">HYPER</div>
        <div class="ctl" id="restartBtn" role="button" tabindex="0">RESTART</div>
      </div>

      <div class="hud-right">
        <div class="brand">Orb Runner — BY OPULENT HARDWARE</div>
      </div>
    </div>

    <!-- Swipe Pad -->
    <div class="swipe-wrap" id="swipeWrap" aria-label="Swipe Pad">
      <div class="swipe-pad" id="swipePad">
        <div class="streak" id="streak"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  window.addEventListener('contextmenu', e => e.preventDefault());

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  const hudScore = document.getElementById('score');
  const hudLen   = document.getElementById('length');

  const restartBtn = document.getElementById('restartBtn');
  const mediumBtn  = document.getElementById('mediumBtn');
  const fastBtn    = document.getElementById('fastBtn');
  const hyperBtn   = document.getElementById('hyperBtn');

  const swipePad   = document.getElementById('swipePad');
  const streak     = document.getElementById('streak');

  /* --------- Config --------- */
  // Medium is slowest as requested
  const SPEED_LEVELS = { Medium: 12, Fast: 18, Hyper: 24 }; // base CPS
  let currentLevel = localStorage.getItem('orbRunnerLevel') || 'Medium';

  // Length-based bonus: +1 CPS per 5 segments, capped +10 CPS
  function speedFromLength(base, len){
    const bonus = Math.min(10, Math.floor(Math.max(0, len - 1) / 5));
    return base + bonus;
  }

  const DIR = { LEFT:0, UP:1, RIGHT:2, DOWN:3 };

  /* --------- Utils --------- */
  const on = (el, evts, fn, opts={}) => evts.forEach(evt => el.addEventListener(evt, fn, opts));
  const prevent = fn => (e)=>{ e.preventDefault(); fn(e); };
  const clamp01 = v => (v < 0 ? 0 : (v > 1 ? 1 : v));

  /* --------- Canvas & Grid --------- */
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function fitCanvas(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width  = Math.round(w * DPR); canvas.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  new ResizeObserver(fitCanvas).observe(canvas);
  fitCanvas();

  function gridFromViewport() {
    const vw = canvas.clientWidth, vh = canvas.clientHeight;
    const targetCell = Math.max(28, Math.min(44, Math.floor(Math.min(vw, vh) / 20)));
    const cols = Math.max(8, Math.floor(vw / targetCell));
    const rows = Math.max(8, Math.floor(vh / targetCell));
    const cell = Math.floor(Math.min(vw/cols, vh/rows));
    const ox = Math.floor((vw - cols*cell)/2);
    const oy = Math.floor((vh - rows*cell)/2);
    return { cols, rows, cell, ox, oy };
  }
  let grid = gridFromViewport();

  // Defer grid updates while alive to keep speed visually constant
  let resizeTimer = null, pendingResize = false;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      if (!G.alive) {
        grid = gridFromViewport();
      } else {
        pendingResize = true; // apply when dead/restart
      }
      fitCanvas();
    }, 250);
  });

  /* --------- Game State --------- */
  function newGame() {
    if (pendingResize) { grid = gridFromViewport(); pendingResize = false; }
    const midx = Math.floor(grid.cols/2), midy = Math.floor(grid.rows/2);
    const base = SPEED_LEVELS[currentLevel];
    const effective = speedFromLength(base, 1);
    const step = 1 / Math.max(1, effective);
    return {
      snake: [{x:midx, y:midy}],
      prevSnake: [{x:midx, y:midy}],  // for interpolation
      dir: DIR.RIGHT, nextDir: DIR.RIGHT,
      food: spawnFood([{x:midx,y:midy}]),
      score: 0, alive: true,
      baseSpeed: base,  // base tier CPS
      speed: effective, // effective CPS (with length bonus)
      tickAcc: 0,
      lastStepTime: step,
      steps: 0
    };
  }

  function spawnFood(blocked) {
    const used = new Set(blocked.map(p => p.x + "," + p.y));
    let x, y;
    do { x = Math.floor(Math.random()*grid.cols); y = Math.floor(Math.random()*grid.rows); }
    while (used.has(x + "," + y));
    return {x,y};
  }

  let G = newGame();

  /* --------- HUD (no speed) --------- */
  let lastHudMs = 0;
  function updateHUD(){
    hudScore.textContent = "SCORE " + G.score;
    hudLen.textContent   = "LEN " + G.snake.length;

    // Glow color keyed to effective speed
    const root = document.documentElement;
    const s = G.speed;
    if (s <= SPEED_LEVELS.Medium + 3) root.style.setProperty('--gridGlow', '#00ff4c');   // green
    else if (s < SPEED_LEVELS.Hyper)  root.style.setProperty('--gridGlow', '#ffb020');   // amber
    else                              root.style.setProperty('--gridGlow', '#ff3b30');   // red

    // button active states
    [mediumBtn, fastBtn, hyperBtn].forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed','false'); });
    if (currentLevel === 'Medium') { mediumBtn.classList.add('active'); mediumBtn.setAttribute('aria-pressed','true'); }
    if (currentLevel === 'Fast')   { fastBtn.classList.add('active');   fastBtn.setAttribute('aria-pressed','true'); }
    if (currentLevel === 'Hyper')  { hyperBtn.classList.add('active');  hyperBtn.setAttribute('aria-pressed','true'); }
  }
  function maybeUpdateHUD(nowMs){
    if (nowMs - lastHudMs > 100) { // ~10 Hz
      updateHUD();
      lastHudMs = nowMs;
    }
  }

  /* --------- Speed management with hitch-free rescale --------- */
  function setEffectiveSpeed(newSpeed){
    const oldStep = G.lastStepTime;
    const newStep = 1 / Math.max(1, newSpeed);
    // Rescale accumulator to avoid a visible hitch on speed change
    G.tickAcc = Math.min(newStep, G.tickAcc * (newStep / oldStep));
    G.speed = newSpeed;
    G.lastStepTime = newStep;
  }

  function applyLengthSpeed(){
    const effective = speedFromLength(G.baseSpeed, G.snake.length);
    setEffectiveSpeed(effective);
  }

  function setSpeedLevel(level){
    currentLevel = level;
    localStorage.setItem('orbRunnerLevel', level);
    G.baseSpeed = SPEED_LEVELS[level];
    applyLengthSpeed(); // recalculates with current length and rescales accumulator
    updateHUD();
  }

  /* --------- Controls --------- */
  window.addEventListener('keydown', (e) => {
    if (e.key === '1') setSpeedLevel('Medium');
    if (e.key === '2') setSpeedLevel('Fast');
    if (e.key === '3') setSpeedLevel('Hyper');
    if (e.key === 'r') restart();
    if (e.key === 'ArrowLeft' || e.key === 'a') setDir((G.dir + 3) % 4);
    if (e.key === 'ArrowRight'|| e.key === 'd') setDir((G.dir + 1) % 4);
    if (e.key === 'ArrowUp'   || e.key === 'w') setDir(DIR.UP);
    if (e.key === 'ArrowDown' || e.key === 's') setDir(DIR.DOWN);
  });

  on(restartBtn, ['pointerup','click'], prevent(()=>restart()), {passive:false});
  on(mediumBtn,  ['pointerup','click'], prevent(()=>setSpeedLevel('Medium')), {passive:false});
  on(fastBtn,    ['pointerup','click'], prevent(()=>setSpeedLevel('Fast')),   {passive:false});
  on(hyperBtn,   ['pointerup','click'], prevent(()=>setSpeedLevel('Hyper')),  {passive:false});

  function restart(){
    G = newGame();
    swipeClear();
    updateHUD();
  }

  function setDir(d){ G.nextDir = d; }

  /* --------- Swipe/Flick --------- */
  let swipeStart = null;
  const SWIPE_MIN = 18;

  on(swipePad, ['pointerdown','touchstart'], prevent((e)=>{
    swipeStart = getPoint(e, swipePad);
  }), {passive:false});

  on(swipePad, ['pointerup','touchend'], prevent((e)=>{
    if (!swipeStart) return;
    const p = getPoint(e, swipePad);
    const dx = p.x - swipeStart.x, dy = p.y - swipeStart.y;
    const mag = Math.hypot(dx, dy);

    if (mag >= SWIPE_MIN) {
      const ang = Math.atan2(dy, dx);
      showStreak(ang);
      const ax = Math.abs(dx), ay = Math.abs(dy);
      if (ax > ay) setDir(dx < 0 ? DIR.LEFT : DIR.RIGHT);
      else         setDir(dy < 0 ? DIR.UP   : DIR.DOWN );
    } else {
      pulsePad();
    }
    swipeStart = null;
    updateHUD();
  }), {passive:false});

  function getPoint(e, relativeToEl){
    const rect = relativeToEl.getBoundingClientRect();
    let cx, cy;
    if (e.changedTouches && e.changedTouches[0]) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
    else { cx = e.clientX; cy = e.clientY; }
    return { x: cx-rect.left, y: cy-rect.top, w: rect.width, h: rect.height };
  }

  function showStreak(angle){
    streak.style.opacity = '1';
    streak.style.transform = `translateZ(0) rotate(${angle}rad)`;
    pulsePad();
    clearTimeout(showStreak._t);
    showStreak._t = setTimeout(()=>{ streak.style.opacity = '0'; }, 160);
  }
  function pulsePad(){ swipePad.classList.remove('pulse'); void swipePad.offsetWidth; swipePad.classList.add('pulse'); }
  function swipeClear(){ streak.style.opacity = '0'; swipePad.classList.remove('pulse'); }

  /* --------- Simulation + Interpolation --------- */
  const wrap = (v, m) => (v + m) % m;
  function snapshotSnake(arr) { return arr.map(p => ({x:p.x, y:p.y})); }

  function tick(){
    // For interpolation
    G.prevSnake = snapshotSnake(G.snake);

    G.dir = validateTurn(G.dir, G.nextDir);
    const head = G.snake[0];
    const nx = wrap(head.x + (G.dir===DIR.RIGHT?1:G.dir===DIR.LEFT?-1:0), grid.cols);
    const ny = wrap(head.y + (G.dir===DIR.DOWN?1:G.dir===DIR.UP?-1:0), grid.rows);
    const newHead = {x:nx, y:ny};

    // Self collision
    for (let i=0;i<G.snake.length;i++){
      if (G.snake[i].x===newHead.x && G.snake[i].y===newHead.y) { G.alive = false; return; }
    }

    G.snake.unshift(newHead);

    if (newHead.x === G.food.x && newHead.y === G.food.y) {
      G.score += 1;
      G.food = spawnFood(G.snake);
      // Length changed -> recompute effective speed and rescale accumulator
      applyLengthSpeed();
    } else {
      G.snake.pop();
    }

    G.steps++;
  }

  function validateTurn(cur, nxt){
    if ((cur===DIR.LEFT && nxt===DIR.RIGHT) ||
        (cur===DIR.RIGHT&& nxt===DIR.LEFT)  ||
        (cur===DIR.UP   && nxt===DIR.DOWN)  ||
        (cur===DIR.DOWN && nxt===DIR.UP)) return cur;
    return nxt;
  }

  /* --------- Main Loop (fixed-step sim, interpolated render) --------- */
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.06, (now - last)/1000); // cap for tab thrash
    last = now;

    if (G.alive) {
      const stepTime = 1 / Math.max(1, G.speed);
      G.lastStepTime = stepTime; // record for this frame's interpolation
      G.tickAcc += dt;
      while (G.tickAcc >= stepTime) {
        tick();
        G.tickAcc -= stepTime;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  /* --------- Drawing (Interpolated) --------- */
  function draw(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,w,h);

    // Background vignette
    const grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h)*0.7);
    grad.addColorStop(0, "rgba(0,0,0,0)");
    grad.addColorStop(1, "rgba(0,0,0,0.6)");
    ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

    const c = grid.cell, ox = grid.ox, oy = grid.oy;

    // Interpolation factor (0..1)
    const f = clamp01(G.tickAcc / G.lastStepTime);

    // Food (pulsing)
    const t = performance.now()*0.002;
    const pulse = 0.4 + 0.2*Math.sin(t);
    const fx = ox + G.food.x*c + c/2;
    const fy = oy + G.food.y*c + c/2;

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 24; ctx.shadowColor = '#36a8ff';
    ctx.fillStyle = `rgba(54,168,255,${0.7 + 0.3*pulse})`;
    circle(fx, fy, Math.max(4, c*0.22*(1+pulse)));
    ctx.restore();

    // Snake (interpolated)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const glow = getComputedStyle(document.documentElement).getPropertyValue('--gridGlow').trim() || '#00ff4c';
    ctx.shadowBlur = 22; ctx.shadowColor = glow;

    const rgbaCache = {};
    function glowRGBA(alpha){ return rgbaCache[alpha] || (rgbaCache[alpha] = hexToRGBA(glow, alpha)); }

    for (let i=0;i<G.snake.length;i++){
      const cur = G.snake[i];
      const prv = (G.prevSnake[i] || cur);

      // Wrap-aware shortest path
      let dx = cur.x - prv.x, dy = cur.y - prv.y;
      if (dx >  grid.cols/2)  dx -= grid.cols;
      if (dx < -grid.cols/2)  dx += grid.cols;
      if (dy >  grid.rows/2)  dy -= grid.rows;
      if (dy < -grid.rows/2)  dy += grid.rows;

      const ix = prv.x + dx * f;
      const iy = prv.y + dy * f;

      const px = ox + ((ix % grid.cols + grid.cols) % grid.cols)*c + c/2;
      const py = oy + ((iy % grid.rows + grid.rows) % grid.rows)*c + c/2;

      const a = (i===0) ? 0.95 : Math.max(0.25, 0.9 - i*0.02);
      ctx.fillStyle = glowRGBA(a);
      circle(px, py, Math.max(4, c*0.24));
    }
    ctx.restore();

    // HUD (throttled)
    maybeUpdateHUD(performance.now());

    // Fade on death
    if (!G.alive) {
      ctx.save(); ctx.fillStyle = "rgba(0,0,0,0.28)"; ctx.fillRect(0,0,w,h); ctx.restore();
    }
  }

  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); ctx.fill(); }

  function hexToRGBA(hex, a=1){
    const h = hex.replace('#','');
    const bigint = parseInt(h.length===3 ? h.split('').map(ch=>ch+ch).join('') : h, 16);
    const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
    return `rgba(${r},${g},${b},${a})`;
  }

  /* --------- Boot --------- */
  // Initialize tier selection / base speed then compute effective speed & HUD
  (function init(){
    // reflect stored level on buttons
    if (currentLevel !== 'Medium') { [mediumBtn, fastBtn, hyperBtn].forEach(b=>b.classList.remove('active')); }
    if (currentLevel === 'Fast')   fastBtn.classList.add('active');
    if (currentLevel === 'Hyper')  hyperBtn.classList.add('active');

    G.baseSpeed = SPEED_LEVELS[currentLevel];
    applyLengthSpeed();
    updateHUD();
  })();
})();
</script>
</body>
</html>
