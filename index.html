<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Orb Runner — Cosmic BG (Iframe Optimized)</title>
<style>
  :root{
    /* Cosmic palette */
    --bg:#060612;
    --nebula1:#5b3bff;   /* indigo */
    --nebula2:#1aa4ff;   /* cyan   */
    --nebula3:#ff6b2c;   /* orange */
    --star:#ffffff;
    --snake:#11d36d;     /* base green */
    --snake-warn:#ffb020;/* amber     */
    --snake-hot:#ff3b30; /* red       */
    --food:#36a8ff;      /* blue      */
    --hud:#e8e8e8;
    --brand:rgba(255,255,255,0.9);
  }
  html, body {
    height:100%; width:100%; margin:0; background:var(--bg); color:var(--hud);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overscroll-behavior:none; touch-action:none; -webkit-user-select:none; user-select:none;
  }
  * { -webkit-tap-highlight-color: transparent; }
  .stage { position:fixed; inset:0; background:var(--bg); }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; pointer-events:auto; }

  /* HUD */
  .hud {
    position:absolute; left:12px; right:12px; top:10px; z-index:10;
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center; gap:10px;
    pointer-events:none;
  }
  .hud-left,.hud-center,.hud-right { display:flex; align-items:center; gap:10px; }
  .hud-center { justify-content:center; pointer-events:auto; }
  .badge {
    padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.08);
    font-weight:700; letter-spacing:.4px; white-space:nowrap;
    border:1px solid rgba(255,255,255,0.12);
  }
  .ctl {
    padding:8px 14px; border-radius:999px; background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.12); font-weight:800; letter-spacing:.4px;
    cursor:pointer; user-select:none; touch-action:manipulation;
  }
  .ctl:active { transform:scale(0.98); }
  .ctl.active { background:rgba(255,255,255,0.16); border-color:rgba(255,255,255,0.3); }
  .brand { white-space:nowrap; font-weight:700; color:var(--brand); opacity:.95; }

  /* Swipe Pad */
  .swipe-wrap {
    position:absolute; bottom:22px; left:50%; transform:translateX(-50%);
    width:min(38vw,220px); height:min(38vw,220px); display:grid; place-items:center; z-index:10; pointer-events:auto;
  }
  .swipe-pad {
    width:100%; height:100%; border-radius:50%;
    border:2px solid rgba(255,255,255,0.15);
    background:rgba(255,255,255,0.02);
    position:relative;
  }
  .swipe-pad::after{ content:""; position:absolute; inset:10%; border-radius:50%; border:1px dashed rgba(255,255,255,0.15); }
  .streak{ position:absolute; width:6%; height:40%; top:10%; left:47%; border-radius:999px; background:rgba(255,255,255,0.6); opacity:0; transition:opacity 120ms ease; pointer-events:none; transform-origin:50% 100%; }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>

    <!-- HUD -->
    <div class="hud" aria-label="HUD">
      <div class="hud-left">
        <div class="badge" id="score">SCORE 0</div>
        <div class="badge" id="length">LEN 1</div>
      </div>

      <div class="hud-center" aria-label="Speed Controls">
        <div class="ctl active" id="mediumBtn" role="button" tabindex="0" aria-pressed="true">MEDIUM</div>
        <div class="ctl" id="fastBtn"   role="button" tabindex="0" aria-pressed="false">FAST</div>
        <div class="ctl" id="hyperBtn"  role="button" tabindex="0" aria-pressed="false">HYPER</div>
        <div class="ctl" id="restartBtn" role="button" tabindex="0">RESTART</div>
      </div>

      <div class="hud-right">
        <div class="brand">Orb Runner — BY OPULENT HARDWARE</div>
      </div>
    </div>

    <!-- Swipe Pad -->
    <div class="swipe-wrap" aria-label="Swipe Pad">
      <div class="swipe-pad" id="swipePad">
        <div class="streak" id="streak"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  window.addEventListener('contextmenu', e => e.preventDefault());

  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hudScore = document.getElementById('score');
  const hudLen   = document.getElementById('length');
  const restartBtn = document.getElementById('restartBtn');
  const mediumBtn  = document.getElementById('mediumBtn');
  const fastBtn    = document.getElementById('fastBtn');
  const hyperBtn   = document.getElementById('hyperBtn');
  const swipePad   = document.getElementById('swipePad');
  const streak     = document.getElementById('streak');

  // Config (tiers + ramp)
  const SPEED_LEVELS = { Medium:12, Fast:18, Hyper:24 }; // base CPS (Medium is slowest)
  let currentLevel = 'Medium';
  const lengthBonus = (len) => Math.min(10, Math.floor(Math.max(0, len-1)/5)); // +1 CPS / 5 segments, cap +10
  const effectiveSpeed = (base, len) => base + lengthBonus(len);

  // Helpers
  const DIR = { LEFT:0, UP:1, RIGHT:2, DOWN:3 };
  const on = (el,evts,fn,opts={}) => evts.forEach(evt=>el.addEventListener(evt,fn,opts));
  const prevent = fn => e=>{ e.preventDefault(); fn(e); };
  const clamp01 = v => v<0?0:(v>1?1:v);
  const wrap = (v,m) => (v+m)%m;
  const CSS = getComputedStyle(document.documentElement);
  const colorVar = name => CSS.getPropertyValue(name).trim();

  // Canvas & grid (DPR clamped to 1 for lighter compositing)
  let DPR = 1;
  function fitCanvas(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.round(w * DPR); canvas.height = Math.round(h * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    buildBackground(); // rebuild offscreen background on resize
  }
  new ResizeObserver(fitCanvas).observe(canvas); fitCanvas();

  function gridFromViewport(){
    const vw = canvas.clientWidth, vh = canvas.clientHeight;
    const targetCell = Math.max(28, Math.min(44, Math.floor(Math.min(vw,vh)/20)));
    const cols = Math.max(8, Math.floor(vw/targetCell));
    const rows = Math.max(8, Math.floor(vh/targetCell));
    const cell = Math.floor(Math.min(vw/cols, vh/rows));
    const ox = Math.floor((vw - cols*cell)/2);
    const oy = Math.floor((vh - rows*cell)/2);
    return { cols, rows, cell, ox, oy };
  }
  let grid = gridFromViewport();
  let resizeTimer=null;
  window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>{ grid=gridFromViewport(); fitCanvas(); }, 150); });

  // ---------- Procedural cosmic background ----------
  let bgCanvas, bgCtx, twinkleStars=[];
  function buildBackground(){
    const w = canvas.width, h = canvas.height;
    bgCanvas = document.createElement('canvas');
    bgCanvas.width = w; bgCanvas.height = h;
    bgCtx = bgCanvas.getContext('2d');

    // Base fill
    bgCtx.fillStyle = colorVar('--bg') || '#060612';
    bgCtx.fillRect(0,0,w,h);

    // Soft nebula clouds: 3–4 large radial gradients
    drawNebula(bgCtx, w, h);

    // Starfield: many faint stars (static)
    drawStaticStars(bgCtx, w, h, 220); // count

    // Twinklers: small set we animate each frame
    twinkleStars = makeTwinkleStars(w, h, 36);
  }

  function drawNebula(c, w, h){
    // helper for a radial gradient blob
    function blob(x, y, r, color, alpha){
      const g = c.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0, hexWithA(color, alpha));
      g.addColorStop(1, hexWithA(color, 0));
      c.fillStyle = g;
      c.beginPath(); c.arc(x, y, r, 0, Math.PI*2); c.fill();
    }
    const w2=w/2, h2=h/2;
    blob(w2*0.55, h2*0.45, Math.max(w,h)*0.55, colorVar('--nebula1')||'#5b3bff', 0.18);
    blob(w2*0.35, h2*0.65, Math.max(w,h)*0.60, colorVar('--nebula2')||'#1aa4ff', 0.14);
    blob(w2*0.85, h2*0.75, Math.max(w,h)*0.50, colorVar('--nebula3')||'#ff6b2c', 0.10);
    blob(w2*0.15, h2*0.30, Math.max(w,h)*0.40, colorVar('--nebula1')||'#5b3bff', 0.10);
  }

  function drawStaticStars(c, w, h, count){
    const star = colorVar('--star') || '#ffffff';
    c.fillStyle = star;
    for (let i=0;i<count;i++){
      const x = Math.random()*w;
      const y = Math.random()*h;
      const r = Math.random()<0.85 ? 0.6 : 1.0; // mostly faint
      c.globalAlpha = 0.25 + Math.random()*0.25;
      c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
    }
    c.globalAlpha = 1;
  }

  function makeTwinkleStars(w, h, count){
    const arr = [];
    for (let i=0;i<count;i++){
      arr.push({
        x: Math.random()*w,
        y: Math.random()*h,
        r: 0.9 + Math.random()*1.2,
        base: 0.35 + Math.random()*0.25,
        amp: 0.25 + Math.random()*0.35,
        // different speeds/phases so they don't sync
        speed: 0.5 + Math.random()*1.2,
        phase: Math.random()*Math.PI*2
      });
    }
    return arr;
  }

  function drawTwinkles(c, t){
    const star = colorVar('--star') || '#ffffff';
    c.fillStyle = star;
    for (const s of twinkleStars){
      const a = s.base + s.amp * 0.5*(1+Math.sin(s.phase + t*s.speed));
      c.globalAlpha = a;
      c.beginPath(); c.arc(s.x, s.y, s.r, 0, Math.PI*2); c.fill();
    }
    c.globalAlpha = 1;
  }

  function hexWithA(hex, a){
    // accept #rgb or #rrggbb
    const h = hex.replace('#','');
    const v = parseInt(h.length===3 ? h.split('').map(ch=>ch+ch).join('') : h, 16);
    const r=(v>>16)&255, g=(v>>8)&255, b=v&255;
    return `rgba(${r},${g},${b},${a})`;
  }

  // ---------- Game state ----------
  function snapshotSnake(a){ return a.map(p=>({x:p.x,y:p.y})); }
  function spawnFood(blocked){
    const used = new Set(blocked.map(p=>p.x+','+p.y));
    let x,y; do { x=Math.floor(Math.random()*grid.cols); y=Math.floor(Math.random()*grid.rows); } while(used.has(x+','+y));
    return {x,y};
  }
  function newGame(){
    grid = gridFromViewport();
    const midx = Math.floor(grid.cols/2), midy = Math.floor(grid.rows/2);
    const base = SPEED_LEVELS[currentLevel];
    const eff  = effectiveSpeed(base, 1);
    const step = 1/Math.max(1, eff);
    return {
      snake:[{x:midx,y:midy}], prevSnake:[{x:midx,y:midy}],
      dir:DIR.RIGHT, nextDir:DIR.RIGHT,
      food: spawnFood([{x:midx,y:midy}]),
      score:0, alive:true,
      baseSpeed: base, speed: eff,
      tickAcc:0, lastStepTime: step, steps:0,
      _cellAcc:0
    };
  }
  let G = newGame();

  // HUD
  function updateHUD(){
    hudScore.textContent = "SCORE " + G.score;
    hudLen.textContent   = "LEN " + G.snake.length;
    [mediumBtn,fastBtn,hyperBtn].forEach(b=>{ b.classList.remove('active'); b.setAttribute('aria-pressed','false'); });
    if (currentLevel==='Medium'){ mediumBtn.classList.add('active'); mediumBtn.setAttribute('aria-pressed','true'); }
    if (currentLevel==='Fast')  { fastBtn.classList.add('active');   fastBtn.setAttribute('aria-pressed','true'); }
    if (currentLevel==='Hyper') { hyperBtn.classList.add('active');  hyperBtn.setAttribute('aria-pressed','true'); }
  }
  updateHUD();

  // Speed management (rescale accumulator to avoid hitch)
  function setEffectiveSpeed(newSpeed){
    const oldStep = G.lastStepTime || (1/Math.max(1,G.speed||12));
    const newStep = 1/Math.max(1,newSpeed);
    G.tickAcc = Math.min(newStep, G.tickAcc * (newStep/oldStep));
    G.speed = newSpeed; G.lastStepTime = newStep;
  }
  function applyLengthSpeed(){ setEffectiveSpeed(effectiveSpeed(G.baseSpeed, G.snake.length)); }
  function setSpeedLevel(level){ currentLevel = level; G.baseSpeed = SPEED_LEVELS[level]; applyLengthSpeed(); updateHUD(); }

  // Controls
  window.addEventListener('keydown', (e)=>{
    if (e.key==='1') setSpeedLevel('Medium');
    if (e.key==='2') setSpeedLevel('Fast');
    if (e.key==='3') setSpeedLevel('Hyper');
    if (e.key==='r') restart();
    if (e.key==='ArrowLeft'||e.key==='a') setDir((G.dir+3)%4);
    if (e.key==='ArrowRight'||e.key==='d') setDir((G.dir+1)%4);
    if (e.key==='ArrowUp'||e.key==='w') setDir(DIR.UP);
    if (e.key==='ArrowDown'||e.key==='s') setDir(DIR.DOWN);
  });
  on(restartBtn,['pointerup','click'],prevent(()=>restart()),{passive:false});
  on(mediumBtn,['pointerup','click'],prevent(()=>setSpeedLevel('Medium')),{passive:false});
  on(fastBtn,  ['pointerup','click'],prevent(()=>setSpeedLevel('Fast')),{passive:false});
  on(hyperBtn, ['pointerup','click'],prevent(()=>setSpeedLevel('Hyper')),{passive:false});

  function restart(){ G = newGame(); swipeClear(); updateHUD(); }
  function setDir(d){ G.nextDir = d; }

  // Swipe
  let swipeStart=null; const SWIPE_MIN=18;
  on(swipePad,['pointerdown','touchstart'],prevent(e=>{ swipeStart=getPoint(e,swipePad); }),{passive:false});
  on(swipePad,['pointerup','touchend'],prevent(e=>{
    if(!swipeStart) return;
    const p=getPoint(e,swipePad); const dx=p.x-swipeStart.x, dy=p.y-swipeStart.y; const mag=Math.hypot(dx,dy);
    if(mag>=SWIPE_MIN){
      const ang=Math.atan2(dy,dx); showStreak(ang);
      const ax=Math.abs(dx), ay=Math.abs(dy);
      if(ax>ay) setDir(dx<0?DIR.LEFT:DIR.RIGHT); else setDir(dy<0?DIR.UP:DIR.DOWN);
    }
    swipeStart=null; updateHUD();
  }),{passive:false});
  function getPoint(e,el){ const r=el.getBoundingClientRect(); let cx,cy;
    if(e.changedTouches&&e.changedTouches[0]){ cx=e.changedTouches[0].clientX; cy=e.changedTouches[0].clientY; }
    else { cx=e.clientX; cy=e.clientY; }
    return { x:cx-r.left, y:cy-r.top };
  }
  function showStreak(a){ streak.style.opacity='1'; streak.style.transform=`translateZ(0) rotate(${a}rad)`; clearTimeout(showStreak._t); showStreak._t=setTimeout(()=>{streak.style.opacity='0';},140); }
  function swipeClear(){ streak.style.opacity='0'; }

  // Simulation (fixed 60 FPS step) + interpolation per-cell
  const TARGET_FPS = 60;
  const STEP = 1 / TARGET_FPS;
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.1, (now-last)/1000); last = now;
    G.tickAcc += dt;
    while (G.tickAcc >= STEP){
      if (!G.alive) break;
      fixedTick();
      G.tickAcc -= STEP;
    }
    draw(now*0.001, G.tickAcc / STEP);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function fixedTick(){
    // snapshot for interpolation
    G.prevSnake = snapshotSnake(G.snake);

    // move when enough time for one cell has accumulated
    const cellTime = 1/Math.max(1,G.speed);
    G._cellAcc += STEP;
    if (G._cellAcc < cellTime) return;
    G._cellAcc -= cellTime;

    G.dir = validateTurn(G.dir, G.nextDir);
    const head = G.snake[0];
    const nx = wrap(head.x + (G.dir===DIR.RIGHT?1:G.dir===DIR.LEFT?-1:0), grid.cols);
    const ny = wrap(head.y + (G.dir===DIR.DOWN?1:G.dir===DIR.UP?-1:0), grid.rows);
    const newHead = {x:nx, y:ny};

    for (let i=0;i<G.snake.length;i++){ if (G.snake[i].x===newHead.x && G.snake[i].y===newHead.y){ G.alive=false; return; } }

    G.snake.unshift(newHead);
    if (newHead.x===G.food.x && newHead.y===G.food.y){
      G.score += 1;
      G.food = spawnFood(G.snake);
      setEffectiveSpeed(effectiveSpeed(G.baseSpeed, G.snake.length)); // ramp with length
    } else {
      G.snake.pop();
    }
    G.steps++;
  }

  function validateTurn(cur,nxt){
    if ((cur===DIR.LEFT && nxt===DIR.RIGHT) || (cur===DIR.RIGHT&&nxt===DIR.LEFT) ||
        (cur===DIR.UP && nxt===DIR.DOWN) || (cur===DIR.DOWN&&nxt===DIR.UP)) return cur;
    return nxt;
  }

  // Draw (background -> twinkles -> food -> snake -> HUD fade)
  function draw(t, f){
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // Background (offscreen)
    ctx.drawImage(bgCanvas, 0, 0, w, h);

    // Twinkling stars (few, cheap)
    drawTwinkles(ctx, t);

    const c = grid.cell, ox = grid.ox, oy = grid.oy;

    // FOOD (solid circle)
    ctx.fillStyle = colorVar('--food') || '#36a8ff';
    const fx = ox + G.food.x*c + c/2, fy = oy + G.food.y*c + c/2;
    circle(fx, fy, Math.max(4, c*0.22));

    // SNAKE (solid circles, interpolated within current cell)
    // compute cell progress
    const cellTime = 1/Math.max(1,G.speed);
    const cellF = clamp01(G._cellAcc / cellTime);

    // color based on speed tier
    const s = G.speed;
    let snakeColor = colorVar('--snake') || '#11d36d';
    if (s > 22) snakeColor = colorVar('--snake-hot') || '#ff3b30';
    else if (s > 15) snakeColor = colorVar('--snake-warn') || '#ffb020';

    ctx.fillStyle = snakeColor;
    for (let i=0;i<G.snake.length;i++){
      const cur = G.snake[i];
      const prv = (G.prevSnake[i] || cur);

      let dx = cur.x - prv.x, dy = cur.y - prv.y;
      if (dx >  grid.cols/2) dx -= grid.cols; if (dx < -grid.cols/2) dx += grid.cols;
      if (dy >  grid.rows/2) dy -= grid.rows; if (dy < -grid.rows/2) dy += grid.rows;

      const ix = prv.x + dx * cellF;
      const iy = prv.y + dy * cellF;

      const px = ox + ((ix % grid.cols + grid.cols) % grid.cols)*c + c/2;
      const py = oy + ((iy % grid.rows + grid.rows) % grid.rows)*c + c/2;
      circle(px, py, Math.max(4, c*0.24));
    }

    // HUD text (updates each frame; very cheap)
    hudScore.textContent = "SCORE " + G.score;
    hudLen.textContent   = "LEN " + G.snake.length;

    if (!G.alive){
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0,0,w,h);
    }
  }

  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
})();
</script>
</body>
</html>
