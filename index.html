<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Orb Runner — BY OPULENT HARDWARE (Iframe Optimized)</title>
<style>
  :root{
    --bg:#000000;
    --snake:#11d36d;     /* base green */
    --snake-warn:#ffb020;/* amber */
    --snake-hot:#ff3b30; /* red   */
    --food:#36a8ff;      /* blue  */
    --hud:#e8e8e8;
    --brand:rgba(255,255,255,0.9);
  }
  html, body {
    height:100%; width:100%; margin:0; background:var(--bg); color:var(--hud);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    overscroll-behavior:none; touch-action:none; -webkit-user-select:none; user-select:none;
  }
  * { -webkit-tap-highlight-color: transparent; }
  .stage { position:fixed; inset:0; background:#000; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; pointer-events:auto; }

  /* HUD */
  .hud {
    position:absolute; left:12px; right:12px; top:10px; z-index:10;
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center; gap:10px;
    pointer-events:none;
  }
  .hud-left,.hud-center,.hud-right { display:flex; align-items:center; gap:10px; }
  .hud-center { justify-content:center; pointer-events:auto; }
  .badge {
    padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.08);
    font-weight:700; letter-spacing:.4px; white-space:nowrap;
    border:1px solid rgba(255,255,255,0.12);
  }
  .ctl {
    padding:8px 14px; border-radius:999px; background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.12); font-weight:800; letter-spacing:.4px;
    cursor:pointer; user-select:none; touch-action:manipulation;
  }
  .ctl:active { transform:scale(0.98); }
  .ctl.active { background:rgba(255,255,255,0.16); border-color:rgba(255,255,255,0.3); }
  .brand { white-space:nowrap; font-weight:700; color:var(--brand); opacity:.95; }

  /* Swipe Pad */
  .swipe-wrap {
    position:absolute; bottom:22px; left:50%; transform:translateX(-50%);
    width:min(38vw,220px); height:min(38vw,220px); display:grid; place-items:center; z-index:10; pointer-events:auto;
  }
  .swipe-pad {
    width:100%; height:100%; border-radius:50%;
    border:2px solid rgba(255,255,255,0.15);
    background:rgba(255,255,255,0.02);
    position:relative;
  }
  .swipe-pad::after{ content:""; position:absolute; inset:10%; border-radius:50%; border:1px dashed rgba(255,255,255,0.15); }
  .streak{ position:absolute; width:6%; height:40%; top:10%; left:47%; border-radius:999px; background:rgba(255,255,255,0.6); opacity:0; transition:opacity 120ms ease; pointer-events:none; transform-origin:50% 100%; }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>

    <!-- HUD -->
    <div class="hud" aria-label="HUD">
      <div class="hud-left">
        <div class="badge" id="score">SCORE 0</div>
        <div class="badge" id="length">LEN 1</div>
      </div>

      <div class="hud-center" aria-label="Speed Controls">
        <div class="ctl active" id="mediumBtn" role="button" tabindex="0" aria-pressed="true">MEDIUM</div>
        <div class="ctl" id="fastBtn"   role="button" tabindex="0" aria-pressed="false">FAST</div>
        <div class="ctl" id="hyperBtn"  role="button" tabindex="0" aria-pressed="false">HYPER</div>
        <div class="ctl" id="restartBtn" role="button" tabindex="0">RESTART</div>
      </div>

      <div class="hud-right">
        <div class="brand">Orb Runner — BY OPULENT HARDWARE</div>
      </div>
    </div>

    <!-- Swipe Pad -->
    <div class="swipe-wrap" aria-label="Swipe Pad">
      <div class="swipe-pad" id="swipePad">
        <div class="streak" id="streak"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  window.addEventListener('contextmenu', e => e.preventDefault());

  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hudScore = document.getElementById('score');
  const hudLen   = document.getElementById('length');
  const restartBtn = document.getElementById('restartBtn');
  const mediumBtn  = document.getElementById('mediumBtn');
  const fastBtn    = document.getElementById('fastBtn');
  const hyperBtn   = document.getElementById('hyperBtn');
  const swipePad   = document.getElementById('swipePad');
  const streak     = document.getElementById('streak');

  // Config (tiers + ramp)
  const SPEED_LEVELS = { Medium:12, Fast:18, Hyper:24 }; // base CPS (Medium is slowest)
  let currentLevel = 'Medium';
  const lengthBonus = (len) => Math.min(10, Math.floor(Math.max(0, len-1)/5)); // +1 CPS / 5 segs, cap +10
  const effectiveSpeed = (base, len) => base + lengthBonus(len);

  // Helpers
  const DIR = { LEFT:0, UP:1, RIGHT:2, DOWN:3 };
  const on = (el,evts,fn,opts={}) => evts.forEach(evt=>el.addEventListener(evt,fn,opts));
  const prevent = fn => e=>{ e.preventDefault(); fn(e); };
  const clamp01 = v => v<0?0:(v>1?1:v);
  const wrap = (v,m) => (v+m)%m;

  // Canvas & grid (DPR clamped to 1 for lighter compositing)
  let DPR = 1;
  function fitCanvas(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvas.width = Math.round(w * DPR); canvas.height = Math.round(h * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  new ResizeObserver(fitCanvas).observe(canvas); fitCanvas();

  function gridFromViewport(){
    const vw = canvas.clientWidth, vh = canvas.clientHeight;
    const targetCell = Math.max(28, Math.min(44, Math.floor(Math.min(vw,vh)/20)));
    const cols = Math.max(8, Math.floor(vw/targetCell));
    const rows = Math.max(8, Math.floor(vh/targetCell));
    const cell = Math.floor(Math.min(vw/cols, vh/rows));
    const ox = Math.floor((vw - cols*cell)/2);
    const oy = Math.floor((vh - rows*cell)/2);
    return { cols, rows, cell, ox, oy };
  }
  let grid = gridFromViewport();
  let resizeTimer=null;
  window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>{ grid=gridFromViewport(); fitCanvas(); }, 150); });

  // Game state
  function snapshotSnake(a){ return a.map(p=>({x:p.x,y:p.y})); }
  function spawnFood(blocked){
    const used = new Set(blocked.map(p=>p.x+','+p.y));
    let x,y; do { x=Math.floor(Math.random()*grid.cols); y=Math.floor(Math.random()*grid.rows); } while(used.has(x+','+y));
    return {x,y};
  }
  function newGame(){
    grid = gridFromViewport();
    const midx = Math.floor(grid.cols/2), midy = Math.floor(grid.rows/2);
    const base = SPEED_LEVELS[currentLevel];
    const eff  = effectiveSpeed(base, 1);
    const step = 1/Math.max(1, eff);
    return {
      snake:[{x:midx,y:midy}], prevSnake:[{x:midx,y:midy}],
      dir:DIR.RIGHT, nextDir:DIR.RIGHT,
      food: spawnFood([{x:midx,y:midy}]),
      score:0, alive:true,
      baseSpeed: base, speed: eff,
      tickAcc:0, lastStepTime: step, steps:0
    };
  }
  let G = newGame();

  // HUD (no speed text)
  function updateHUD(){
    hudScore.textContent = "SCORE " + G.score;
    hudLen.textContent   = "LEN " + G.snake.length;
    [mediumBtn,fastBtn,hyperBtn].forEach(b=>{ b.classList.remove('active'); b.setAttribute('aria-pressed','false'); });
    if (currentLevel==='Medium'){ mediumBtn.classList.add('active'); mediumBtn.setAttribute('aria-pressed','true'); }
    if (currentLevel==='Fast')  { fastBtn.classList.add('active');   fastBtn.setAttribute('aria-pressed','true'); }
    if (currentLevel==='Hyper') { hyperBtn.classList.add('active');  hyperBtn.setAttribute('aria-pressed','true'); }
  }
  updateHUD();

  // Speed management (rescale accumulator to avoid hitch)
  function setEffectiveSpeed(newSpeed){
    const oldStep = G.lastStepTime || (1/Math.max(1,G.speed||12));
    const newStep = 1/Math.max(1,newSpeed);
    G.tickAcc = Math.min(newStep, G.tickAcc * (newStep/oldStep));
    G.speed = newSpeed; G.lastStepTime = newStep;
  }
  function applyLengthSpeed(){
    setEffectiveSpeed(effectiveSpeed(G.baseSpeed, G.snake.length));
  }
  function setSpeedLevel(level){
    currentLevel = level;
    G.baseSpeed = SPEED_LEVELS[level];
    applyLengthSpeed();
    updateHUD();
  }

  // Controls
  window.addEventListener('keydown', (e)=>{
    if (e.key==='1') setSpeedLevel('Medium');
    if (e.key==='2') setSpeedLevel('Fast');
    if (e.key==='3') setSpeedLevel('Hyper');
    if (e.key==='r') restart();
    if (e.key==='ArrowLeft'||e.key==='a') setDir((G.dir+3)%4);
    if (e.key==='ArrowRight'||e.key==='d') setDir((G.dir+1)%4);
    if (e.key==='ArrowUp'||e.key==='w') setDir(DIR.UP);
    if (e.key==='ArrowDown'||e.key==='s') setDir(DIR.DOWN);
  });
  on(restartBtn,['pointerup','click'],prevent(()=>restart()),{passive:false});
  on(mediumBtn,['pointerup','click'],prevent(()=>setSpeedLevel('Medium')),{passive:false});
  on(fastBtn,  ['pointerup','click'],prevent(()=>setSpeedLevel('Fast')),{passive:false});
  on(hyperBtn, ['pointerup','click'],prevent(()=>setSpeedLevel('Hyper')),{passive:false});

  function restart(){ G = newGame(); swipeClear(); updateHUD(); }
  function setDir(d){ G.nextDir = d; }

  // Swipe
  let swipeStart=null; const SWIPE_MIN=18;
  on(swipePad,['pointerdown','touchstart'],prevent(e=>{ swipeStart=getPoint(e,swipePad); }),{passive:false});
  on(swipePad,['pointerup','touchend'],prevent(e=>{
    if(!swipeStart) return;
    const p=getPoint(e,swipePad); const dx=p.x-swipeStart.x, dy=p.y-swipeStart.y; const mag=Math.hypot(dx,dy);
    if(mag>=SWIPE_MIN){
      const ang=Math.atan2(dy,dx); showStreak(ang);
      const ax=Math.abs(dx), ay=Math.abs(dy);
      if(ax>ay) setDir(dx<0?DIR.LEFT:DIR.RIGHT); else setDir(dy<0?DIR.UP:DIR.DOWN);
    }
    swipeStart=null; updateHUD();
  }),{passive:false});
  function getPoint(e,el){ const r=el.getBoundingClientRect(); let cx,cy;
    if(e.changedTouches&&e.changedTouches[0]){ cx=e.changedTouches[0].clientX; cy=e.changedTouches[0].clientY; }
    else { cx=e.clientX; cy=e.clientY; }
    return { x:cx-r.left, y:cy-r.top };
  }
  function showStreak(a){ streak.style.opacity='1'; streak.style.transform=`translateZ(0) rotate(${a}rad)`; clearTimeout(showStreak._t); showStreak._t=setTimeout(()=>{streak.style.opacity='0';},140); }
  function swipeClear(){ streak.style.opacity='0'; }

  // Simulation (fixed 60 FPS step) + interpolation
  const TARGET_FPS = 60;
  const STEP = 1 / TARGET_FPS;
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.1, (now-last)/1000); last = now;
    G.tickAcc += dt;
    while (G.tickAcc >= STEP){
      if (!G.alive) break;
      fixedTick(STEP);
      G.tickAcc -= STEP;
    }
    draw(G.tickAcc / STEP);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function fixedTick(/*step*/){
    // snapshot for interpolation
    G.prevSnake = snapshotSnake(G.snake);

    // apply speed against fixed step: move when enough time for one cell has accumulated
    const cellTime = 1/Math.max(1,G.speed);
    G._cellAcc = (G._cellAcc || 0) + STEP;
    if (G._cellAcc < cellTime) return;
    G._cellAcc -= cellTime;

    G.dir = validateTurn(G.dir, G.nextDir);
    const head = G.snake[0];
    const nx = wrap(head.x + (G.dir===DIR.RIGHT?1:G.dir===DIR.LEFT?-1:0), grid.cols);
    const ny = wrap(head.y + (G.dir===DIR.DOWN?1:G.dir===DIR.UP?-1:0), grid.rows);
    const newHead = {x:nx, y:ny};

    // self-collision
    for (let i=0;i<G.snake.length;i++){ if (G.snake[i].x===newHead.x && G.snake[i].y===newHead.y){ G.alive=false; return; } }

    G.snake.unshift(newHead);
    if (newHead.x===G.food.x && newHead.y===G.food.y){
      G.score += 1;
      G.food = spawnFood(G.snake);
      setEffectiveSpeed(effectiveSpeed(G.baseSpeed, G.snake.length)); // ramp with length, hitch-free
    } else {
      G.snake.pop();
    }
    G.steps++;
  }

  function validateTurn(cur,nxt){
    if ((cur===DIR.LEFT && nxt===DIR.RIGHT) || (cur===DIR.RIGHT&&nxt===DIR.LEFT) ||
        (cur===DIR.UP && nxt===DIR.DOWN) || (cur===DIR.DOWN&&nxt===DIR.UP)) return cur;
    return nxt;
  }

  // Draw (cheap visuals, interpolated positions)
  function draw(f){
    // f is how far we are into the next fixed step (0..1). Combine with cell progress.
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h); // cheap clear

    const c = grid.cell, ox = grid.ox, oy = grid.oy;

    // pick snake color by current effective speed (no blur)
    const s = G.speed;
    let snakeColor = getComputedStyle(document.documentElement).getPropertyValue('--snake').trim();
    if (s > 22) snakeColor = getComputedStyle(document.documentElement).getPropertyValue('--snake-hot').trim();
    else if (s > 15) snakeColor = getComputedStyle(document.documentElement).getPropertyValue('--snake-warn').trim();

    // Compute additional interpolation within the current cell move
    const cellTime = 1/Math.max(1,G.speed);
    const cellF = clamp01((G._cellAcc || 0) / cellTime);

    // FOOD (solid circle)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--food').trim() || '#36a8ff';
    const fx = ox + G.food.x*c + c/2, fy = oy + G.food.y*c + c/2;
    circle(fx, fy, Math.max(4, c*0.22));

    // SNAKE (solid circles, interpolated)
    ctx.fillStyle = snakeColor;
    for (let i=0;i<G.snake.length;i++){
      const cur = G.snake[i];
      const prv = (G.prevSnake[i] || cur);

      let dx = cur.x - prv.x, dy = cur.y - prv.y;
      if (dx >  grid.cols/2) dx -= grid.cols; if (dx < -grid.cols/2) dx += grid.cols;
      if (dy >  grid.rows/2) dy -= grid.rows; if (dy < -grid.rows/2) dy += grid.rows;

      const ix = prv.x + dx * cellF;
      const iy = prv.y + dy * cellF;

      const px = ox + ((ix % grid.cols + grid.cols) % grid.cols)*c + c/2;
      const py = oy + ((iy % grid.rows + grid.rows) % grid.rows)*c + c/2;
      circle(px, py, Math.max(4, c*0.24));
    }

    // HUD
    hudScore.textContent = "SCORE " + G.score;
    hudLen.textContent   = "LEN " + G.snake.length;

    // Fade on death (light)
    if (!G.alive){
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0,0,w,h);
    }
  }

  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
})();
</script>
</body>
</html>
